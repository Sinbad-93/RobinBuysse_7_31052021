postUserInfos(identifiant, password, email) {
  //console.log('INSCRIPTION');
  if (this.dataVerify.some(el => email.includes(el))){
        alert('vote e-mail est déjà utilisé, veuillez le modifier pour continuer');
        return
      }
  else if (this.dataVerify.some(el => identifiant.includes(el))){
        alert('vote identifiant est déjà utilisé, veuillez le modifier pour continuer');
        return
      }
  else if(!(identifiant === "") && !(password === "") && !(email === "")
      ){
  // POST request using fetch with error handlingvar 
  const requestOptions = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ identifiant : identifiant, password :password, email : email })};
  fetch('http://rob-developpeur.site/insert', requestOptions)
    .then(response => {
      // check for error response
      if (!response.ok) {
        // get error message from body or default to response status
        const error = (data && data.message) || response.status;
        //console.log('not response ok, error : ' + error);
        alert('une erreur innattendue s\'est produite');
        return Promise.reject(error); 
        }
      const data = response.json()
      .then(data => this.dataGet = data['data'])
      .then(/*data =>*/ //console.log( "Formulaire réponse : " + this.dataGet ),
       // à faire : mettre un load spinner voir une fenetre de choix 
      //console.log('inscription réuissie...'),
      this.newPass = password,
      this.newMail = email,
      this.proposeLogin());})
      .catch(error => {
      this.errorMessage = error;
      console.error('Formulaires, error : ', error);
      return});
      }
      //si un champ est resté vide on ne passe pas dans fetch
    else{
      //console.log('veuillez remplir tous les champs')
      }
},


:class="user.userReactions[28].reactions[0] === 1 ?
        'fas fa-heart interactiveIcons full-heart':'far fa-heart interactiveIcons'"

<button :id_db="id_db" @click="testo(id_db)">testo</button>
    <button @click="findAllReactions">test</button>
        <button @click="testo">test</button>

        <script>
// vuejs with crypto-js - AES256 encrypt | decrypt api login

import CryptoJS from 'crypto-js'
import axios from 'axios'
import format from 'date-fns/format'
const key = '82f2ceed4c503896c8a291e560bd4325' // change to your key
const iv = 'sinasinasisinaaa' // change to your iv
const apiKey = '123xxxyyyzzz' // change to your api key
const username = 'chhumsina'
const password = 'chhumsina@123'
const reqTime = format(new Date(), 'yyyyMMddHHmmss')

export default {
  data() {
    return {
      token: null
    }
  },
  created() {
    this.login()
  },

  methods: {
    aesEncrypt(txt) {
      const cipher = CryptoJS.AES.encrypt(txt, CryptoJS.enc.Utf8.parse(key), {
        iv: CryptoJS.enc.Utf8.parse(iv),
        mode: CryptoJS.mode.CBC
      })

      return cipher.toString()
    },
    aesDencrypt(txt) {
      const cipher = CryptoJS.AES.decrypt(txt, CryptoJS.enc.Utf8.parse(key), {
        iv: CryptoJS.enc.Utf8.parse(iv),
        mode: CryptoJS.mode.CBC
      })

      return CryptoJS.enc.Utf8.stringify(cipher).toString()
    },
    async login() {
      const encPassword = this.aesEncrypt(password)
      const hash = apiKey + reqTime + username + encPassword
      const encHash = this.aesEncrypt(hash)

      const data = {
        req_time: reqTime,
        username,
        password: encPassword,
        hash: encHash
      }

      const headers = {
        'api-key': apiKey
      }
      await axios
        .post('https://your-api-url.com/login', data, {
          headers
        })
        .then((res) => {
          this.token = res.data.token
        })
        .catch((error) => {
          console.log(error)
        })
    }
  }
}
</script>


------------------------------------------------- TRIER
/* on va récuperer toutes les réactions et on va les trier 
      dans parentReactions pour qu'elles soient regroupés par publications */

      //A RETIRER LORSQUE LA CONNEXION SERA OBLIGATOIRE
      //state.userConnectedInfos = JSON.parse(localStorage.getItem("connectedUser"));

      //console.log(data);
      var reactionsObject = data['data'];
      var userReactionsMiror = [];
      var numberOfReactionsMiror = [];
      var countSameId = [];
      var countSameId2 = [];
      //console.log(reactionsObject);
      //console.log(reactionsObject[0]['id_parent_publication']);
      reactionsObject.forEach((key) => {
          // 0 : {rdv_date : 'string'}
          // 0 is key and rdv is i
              //console.log(i);
              //console.log(this.parentReactions);
              //console.log(key['id_parent_publication']);
  // rassembler les réactions de l'utilisateur connecté pour colorer à la connexion 
          if(state.userConnectedInfos.id_user == key['id_user']){
  
              if (!countSameId2.includes(key['id_parent_publication'])){
  
              countSameId2.push(key['id_parent_publication']);
              userReactionsMiror.push({
              id : key['id_parent_publication'], 
              reactions : [
              key['heart'],
              key['smile'],
              key['laugh']
              ], user : key['id_user']
              });
              }
              else{
  
              userReactionsMiror.forEach((index) =>{
              if( index.id === key['id_parent_publication']){
                  if (key['heart'] === 1){
                      index.reactions[0] = 1;
                  }
                  if (key['smile'] === 1){
                      index.reactions[1] = 1;
                  }
                  if (key['laugh'] === 1){
                      index.reactions[2] = 1;
                  }
              }
              });}
            //console.log(countSameId2);
            }
  
  // rassembler toutes les reactions et trier en fonction de l'id de la publication 
          if (!countSameId.includes(key['id_parent_publication'])){
              countSameId.push(key['id_parent_publication']);
              
              numberOfReactionsMiror.push({
              id :key['id_parent_publication'], 
              reactions : [
              key['heart'],
              key['smile'],
              key['laugh']
              ], user : key['id_user']
              })
          }
          else {
              //console.log(this.parentReactions);
              numberOfReactionsMiror.forEach((index) =>{
              //console.log(index[i]);
              //console.log(key['id_parent_publication']);
  
              if (index.id === 
              key['id_parent_publication'])
              { 
                  if (key['heart'] === 1 ){
                      index.reactions[0] += 1;
                  }
                  if (key['smile'] === 1 ){
                      index.reactions[1] += 1;
                  }
                  if (key['laugh'] === 1 ){
                      index.reactions[2] += 1;
                  }
              }
          
          
          })
              }
      });




      ------------------------------------------------------format
      //this.userReactions = userReactionsMiror;
      //this.parentReactions = parentReactionsMiror;
      //console.log(this.parentReactions);
      //console.log(userReactionsMiror);
      var packets = {};
      for(let index = 0; index < userReactionsMiror.length; ++index){
        //console.log(userReactionsMiror[index].id,userReactionsMiror[index].reactions);
  packets[userReactionsMiror[index].id] = {
  reactions: userReactionsMiror[index].reactions,
  user: userReactionsMiror[index].user
  };
  }

  var packets_2 = {};
  for(let index = 0; index < numberOfReactionsMiror.length; ++index){
    packets_2[numberOfReactionsMiror[index].id] = {
    reactions: numberOfReactionsMiror[index].reactions,
    /*user: numberOfReactionsMiror[index].user*/
    };
    }
    console.log('DATA AFTER');
    console.log('USER REACTIONS');
    console.log(packets);
    console.log('NUMBER OF REACTIONS');
    console.log(packets_2);

colorier une emot fleche en noir ou blanc selon le click
    arrowFunction() {
      if (
        event.target.style.color === "black" &&
        event.target.classList.value == this.$refs.topArrow.classList.value
      ) {
        event.target.style.color = "white";
        event.target.nextSibling.nextSibling.style.color = "black";
      } else if (
        event.target.style.color === "black" &&
        event.target != this.$refs.topArrow
      ) {
        event.target.style.color = "white";
        event.target.previousSibling.previousSibling.style.color = "black";
      } else {
        event.target.style.color = "black";
      }
    },

---------------------------------

utiliser class et constructor 


class User {
  constructor(id, mail, name, famillyName) {
    this.id = id;
    this.name = name;
    this.famillyName = famillyName;
    this.mail = mail;
  }
}
let fakeUser21 = new User(21, "Robin", "Fox");
class FakeUser {
  constructor() {
    this.key = "basket";
    // this.content = JSON.parse(localStorage.getItem(this.key))
    // this.content = []
    this.content = [
      {
        id: 22,
        email: "rob1_93@hotmail.fr",
        name: "Robinou",
        famillyName: "Buysse",
        password: "Motdepasse1",
      },
    ];
  }
  _returnAllUser() {
    return this.content;
  }
  _returnLastUser() {
    return this.content[this.content.length - 1];
  }
  _addNewUser(newUser) {
    console.log("On ajoute un utilisateur");
    this.content.push(newUser);
    /*this._save()*/
  }
  _save() {
    localStorage.setItem(this.key, JSON.stringify(this.content));
  }
}
let falseuser = new FakeUser();